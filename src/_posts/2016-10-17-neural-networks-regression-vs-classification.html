---
layout: post
title: "From Regression To Classification"
disqus_id: "neural-networks-3-regression-to-classification"
category: "neural-network"
html_title: "From Regression To Classification - Understanding Neural Networks"
meta_description: "How do you modify a perceptron so that it can handle classification tasks? Read this blog post to find out."
focus_keyword: "Classification"
summary: "This post explains, why we should not use linear regression to solve classification problems. It also describes, what we can do instead to let our neuron tackle classification tasks."
excerpt: "<p>We successfully extended our neuron, so that it can handle all datasets generated by a linear continuous function. Now, we will move to classification tasks, meaning that the target values in the dataset are discrete and not continuous.</p>
<h3>Regression vs. Classification</h3>
<p>So far, all problems were regression tasks. Our neuron was given two input variables, which it used to predict a continuous target variable. In the last problem of the <a href=\"/post/neural-networks-flexible-neurons/\">last post</a>, we introduced a classification problem. The solution for an input vector was either 0 or 1. Our neuron failed to solve this problem because it can only fit a linear function for solving the problem. It generates a least squares fit. For linear regression tasks, this suffices, but for classification problems, the output value should not change linearly, but abruptly.</p>

<figure>
<img src=\"/images/posts/regression-vs-classification/least-squares-fit-classification.png\"/>
<figcaption>The blue line is the neuron's output and the green dotted line is the resulting prediction. We can see that discretizing a value output by a regression done with least squares fit may be a bad idea for classification. From <a href=\"http://www.autonlab.org/tutorials/neural13.pdf\">[1]</a>
</figure>"
tags: [neural-networks, theory]
stylesheets: ""
javascripts: ""
---
<p><a href="https://github.com/batzner/understanding-nn/blob/regression-vs-classification/main.py">Code to this post</a></p>

<p>We successfully extended our neuron, so that it can handle all datasets generated by a linear continuous function. Now, we will move to classification tasks, meaning that the target values in the dataset are discrete and not continuous.</p>
<h3>Regression vs. Classification</h3>
<p>So far, all problems were regression tasks. Our neuron was given two input variables, which it used to predict a continuous target variable. In the last problem of the <a href="/post/neural-networks-flexible-neurons/">last post</a>, we introduced a classification problem. The solution for an input vector was either 0 or 1. Our neuron failed to solve this problem because it can only fit a linear function for solving the problem. It generates a least squares fit. For linear regression tasks, this suffices, but for classification problems, the output value should not change linearly, but abruptly.</p>
<p>A solution would be to output discrete values depending on the neuron's output, for example:</p>
<pre><code>net_input = np.dot(x, weights) + bias
prediction = 0 if net_input <= 0.5 else 1</code></pre>
<p>What this means theoretically is that we are moving away from a least squares fit. A least squares fit tries to find a linear function so that the squared distance between the function and the data points is minimized. That is exactly what we did so far. But for classification, a least squares fit will not always be the best solution. I found a good image in <a href="http://www.autonlab.org/tutorials/neural13.pdf">these slides</a>, which explain the problem more detailed:</p>

<figure>
<img src="/images/posts/regression-vs-classification/least-squares-fit-classification.png"/>
<figcaption>The blue line is the neuron's output and the green dotted line is the resulting prediction. We can see that discretizing a value output by a regression done with least squares fit may be a bad idea for classification. From <a href="http://www.autonlab.org/tutorials/neural13.pdf">[1]</a>
</figure>

<p>The key is to only train the neuron on the samples that it classified wrong. In the code, this means that we do not calculate our error as:</p>
<pre><code>error = np.square(y - net_input)</code></pre>
<p>Instead, we use:</p>
<pre><code>error = np.square(y - prediction)</code></pre>

<h3>Activation Functions</h3>
<p>What we just added is an activation function. We extended our neuron by feeding its weighted sum of inputs into a function that calculates the output. Specifically, we used the step function for activation. Now, the neuron only "fires", if the net input reaches a certain threshold.</p>
<figure>
<img src="/images/posts/regression-vs-classification/neuron-with-activation.png"/>
</figure>
<p>Although the code works for our problem, we got a little careless here. We changed the neuron’s output function and thus the derivative of the error w.r.t. the weights, but we did not modify the update rule. That is because the step function is discontinuous and its derivative is zero except for the step. For now, it is enough to ignore the step function during the weight updates. We tackle this problem in the next post.</p>

<h3>Heading for new shores</h3>
Now that we are able to tackle classification tasks as well, let us try out a new dataset, generated by the XOR function. In the code above, we only change <code>get_target</code> to
<pre><code>def get_target(x):
    return 1 \
        if (x[0] > 0.5 and x[1] <= 0.5) \
           or (x[0] <= 0.5 and x[1] > 0.5) \
        else 0</code></pre>

<p>and again, our neuron fails. Why? Because the data in the new problem are not linearly separable.</p>

<h3>Linear Separability</h3>
<p>Our first problem was defined by</p>
<pre><code>def get_target(x):
    return 1 if 0.58 * x[0] + 0.67 * x[1] + 0.5 > 1 else 0</code></pre>

<p>The definition of the second problem is above. I plotted a dataset with 200 samples and the neuron's decision boundary for each problem below:</p>

<div class="split-figure">
<figure>
<img src="/images/posts/regression-vs-classification/first-problem.png"></canvas>
<figcaption>First Problem</figcaption>
</figure>
<figure>
<img src="/images/posts/regression-vs-classification/second-problem.png"></canvas>
<figcaption>Second Problem</figcaption>
</figure>
</div>

<p>The problem is that our neuron can separate the data only linearly, but the XOR-generated samples are not linearly separable. Note that if we introduce noise into the linearly separable dataset of the first problem, we make it not linearly separable as well. Then, the neuron’s training does not converge, but the decision boundary is still good.</p>
<p>But what is the solution for the XOR dataset? By looking at it, we could say two decisions boundaries. By intuition, we could try to move from a single neuron to our ultimate goal – a neural network.</p>

<h3>Conclusion</h3>
<p>Fail? Success? I am not sure. We modified our neuron so that we can classify data, but the modification was a little careless (we cannot calculate the derivative of the error anymore). Also, the modification was effective for our first dataset, but we immediately reached a new barrier: not linearly separable data. Let us find out, what we can do about this, in the next post.</p>

<p>Next Post: <a href="/post/neural-networks-feed-forward-network/">When one Neuron is not enough</a></p>