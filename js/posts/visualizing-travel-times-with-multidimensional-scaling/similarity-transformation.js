function getSimilarityTransformation(r,t,i=!1){const a=r.rows,n=r.columns,o=getSimilarityTransformationCovariance(r,t),{svd:e,mirrorIdentityForSolution:m}=getSimilarityTransformationSvdWithMirrorIdentities(o,i),l=e.U.mmul(mlMatrix.Matrix.diag(m)).mmul(e.V.transpose()),s=r.variance("row",{unbiased:!1}).reduce((r,t)=>r+t);let u=0;for(let r=0;r<a;r++){const t=m[r];u+=e.diagonal[r]*t}const M=u/s,c=mlMatrix.Matrix.columnVector(r.mean("row")),d=mlMatrix.Matrix.columnVector(t.mean("row")),x=mlMatrix.Matrix.sub(d,mlMatrix.Matrix.mul(l.mmul(c),M));return mlMatrix.Matrix.add(mlMatrix.Matrix.mul(l.mmul(r),M),x.repeat({columns:n}))}function getSimilarityTransformationError(r,t){const i=r.columns,a=mlMatrix.Matrix.sub(t,r);return Math.pow(a.norm("frobenius"),2)/i}function getSimilarityTransformationErrorBound(r,t,i=!1){const a=r.rows,n=(r,t)=>r+t,o=r.variance("row",{unbiased:!1}).reduce(n),e=t.variance("row",{unbiased:!1}).reduce(n),m=getSimilarityTransformationCovariance(r,t),{svd:l,mirrorIdentityForErrorBound:s}=getSimilarityTransformationSvdWithMirrorIdentities(m,i);let u=0;for(let r=0;r<a;r++){const t=s[r];u+=l.diagonal[r]*t}return e-Math.pow(u,2)/o}function getSimilarityTransformationCovariance(r,t){const i=r.rows,a=r.columns,n=mlMatrix.Matrix.columnVector(r.mean("row")),o=mlMatrix.Matrix.columnVector(t.mean("row")),e=mlMatrix.Matrix.zeros(i,i);for(let i=0;i<a;i++){const m=r.getColumnVector(i),l=t.getColumnVector(i),s=mlMatrix.Matrix.sub(l,o).mmul(mlMatrix.Matrix.sub(m,n).transpose());e.addM(mlMatrix.Matrix.div(s,a))}return e}function getSimilarityTransformationSvdWithMirrorIdentities(r,t){const i=r.rows,a=new mlMatrix.SVD(r);let n=Array(a.diagonal.length).fill(1),o=Array(a.diagonal.length).fill(1);if(!t){if(mlMatrix.determinant(r)<0){n[n.length-1]=-1}if(o=n,a.rank===i-1&&(o=Array(a.diagonal.length).fill(1),mlMatrix.determinant(a.U)*mlMatrix.determinant(a.V)<0)){o[o.length-1]=-1}}return{svd:a,mirrorIdentityForErrorBound:n,mirrorIdentityForSolution:o}}